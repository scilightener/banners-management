## Что это
- REST-микросервис, написанный на Go, для управления баннерами. Что такое баннер и другие вводные см. в [общих вводных](#общие-вводные)
- Postgres использовался в качестве персистентного хранилища данных, и Redis для кэширования
- Подробное описание API интерфейса дано в документации openapi: `docs/openapi`

## Команды запуска в Makefile:
- `make docker` - запуск всего приложения и его зависимостей в докер-среде. Для запуска нужен докер. Чтобы отменить - `make docker-down`
- `make run` - локальный запуск проекта (только самого go-приложения). Для запуска нужен postgres, слушающий на 5432 порту, с настроенной политикой безопасности подключений, а также redis на порту 6379 с настроенными кредами для подключения. Эта команда используется в основном для локальной разработки. Для запуска нужен go версии >= 1.22.1
- `make migrate-up` - применяет все миграции для локальной БД (`make migrate-down` для отмены)
- `make docker-deps` - запускает все зависимости в докере. Само go-приложение нужно запускать отдельно. Используется в сочетании с `make run-docker-deps` или для дебага тестов. Чтобы отменить - `make docker-deps-down`
- `make lint` - запуск линтера для кода всего проекта. Для этого локально должен быть установлен golangci-lint. Конфигурация линтера описана в файле `config/.golangci.yml`
- `make test` - запускает тесты, предварительно подняв в докере все зависимости. Для запуска нужен докер. После того, как все тесты завершили свою работу, контейнер с зависимостями в докере автоматически останавливается и удаляется
- `make jwt-user` - получение пользовательского jwt-токена
- `make jwt-admin` - получение админского jwt-токена

## Общие вводные
- Баннер — это JSON-документ, состоящий из полей title, text, url. Тег — это сущность для обозначения группы пользователей; представляет собой число (ID тега).  Фича — это домен или функциональность; представляет собой число (ID фичи).

1. Один баннер может быть связан только с одной фичей и несколькими тегами.
2. При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно.
3. Фича и тег однозначно определяют баннер

## Требования по которым велась разработка
- Для авторизации доступов должны использоваться 2 вида токенов: пользовательский и админский. Получение баннера может происходить с помощью пользовательского или админского токена, а все остальные действия могут выполняться только с помощью админского токена.
- Если при получении баннера передан флаг use_last_revision, необходимо отдавать самую актуальную информацию. В ином случае допускается передача информации, которая была актуальна 5 минут назад.
- Баннеры могут быть временно выключены (поле is_active). Если баннер выключен, то обычные пользователи не должны его получать, при этом админы должны иметь к нему доступ.
- Добавить метод удаления баннеров по фиче или тегу, время ответа которого должно быть константным и не зависеть от текущего количества баннеров (имеется ввиду реализация механизма выполнения отложенных действий).

## Замечания
- К проекту приложена документация openapi (`docs/openapi.yaml`) API-интерфейса сервиса
- К проекту приложена коллекция postman для удобства тестирования (`docs/banners-management.postman_collection.json`)
- Оформление файловой структуры проекта вдохновлено структурой репозитория [golang-standards/project-layout](https://github.com/golang-standards/project-layout)
- При написании кода было соблюдено разделение приложения на слои: model, service, api (handlers)
- Для реализации кэширования на уровне приложения был выбран redis. В нём сохраняются последние запросы пользователей на баннеры. Информация в нём хранится 5 минут
- Для реализации механизма выполнения отложенных действий (для функциональности удаления баннера по фиче и тегу) был использован также redis, а конкретно его функциональность каналов
- Интеграционными тестами (`tests/`) покрыто большинство сценариев работы приложения. Для их запуска необходимо, чтобы были подняты все внешние зависимости приложения (см. `make docker-deps`)
- К проекту приложен конфиг линтера golangci-lint, рекомендациям которого код строго соответствует
- Настроен запуск github workflow на каждый push в ветку main данного репозитория. Workflow запускает проверку линтера, тесты, а затем деплой на удалённый сервер с разворачиванием на нём docker-контейнера с приложением. Развёрнутый сервис доступен по адресу: http://5.42.100.122:22313 (не дудосьте пожалусто умоляю прошу)
